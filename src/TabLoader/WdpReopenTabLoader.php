<?php/* * MIT License * * Copyright (c) 2021-2024 machinateur * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */declare(strict_types=1);namespace Machinateur\ChromeTabTransfer\TabLoader;use Machinateur\ChromeTabTransfer\Exception\FileTemplateDumpException;use Machinateur\ChromeTabTransfer\File\WebsocketWdpClient;use Machinateur\ChromeTabTransfer\Shared\Console;use Machinateur\ChromeTabTransfer\Shared\ConsoleTrait;use Machinateur\ChromeTabTransfer\Shared\DebugFlagTrait;use Machinateur\ChromeTabTransfer\Shared\FileDateTrait;use Symfony\Component\Console\Input\InputInterface;use Symfony\Component\Console\Output\OutputInterface;use Symfony\Component\Filesystem\Exception\IOException;use Symfony\Component\Filesystem\Filesystem;/** * A tab loader that will dump and open a new {@see \Machinateur\ChromeTabTransfer\File\WebsocketWdpClient} script in the browser. * * This implementation is to be used with iphone to restore tabs on the device. This is required to be done via websocket, *  as the usual `/json/new`...` endpoint (used for android) is not supported by `ios_webkit_debug_proxy`. * See {@see } */class WdpReopenTabLoader implements TabLoaderInterface{    use ConsoleTrait {        ConsoleTrait::__construct           as private initializeConsole;        setOutput   as private parent__setOutput;        setInput    as private parent__setInput;        setConsole  as private parent__setConsole;    }    use DebugFlagTrait {        setDebug    as private parent__setDebug;    }    use FileDateTrait {        setFileDate as private parent__setFileDate;    }    use JsonFileTabLoaderTrait {        JsonFileTabLoaderTrait::__construct as private initializeJsonFileTabLoader;    }    private readonly Filesystem $filesystem;    public function __construct(        public readonly int    $port,        public readonly int    $timeout,        public readonly string $file,        public readonly int    $targetPage,    ) {        $this->initializeConsole();        $this->initializeJsonFileTabLoader($this->file);        $this->filesystem = new Filesystem();    }    public function load(): array    {        $this->loadTabs();        $this->dumpWdpClient();        $console = $this->getConsole();        $console->writeln(' ==> ' . __METHOD__ . ':', OutputInterface::VERBOSITY_DEBUG);        // TODO: Dump WDP client script (already done in $driver->start(), launch it in the browser and wait for user confirmation (if non-interactive, wait for $timeout seconds).        //  I might get away with generating the WDP script just-in-time, because it is read synchronously in the IWDP C source code.        // TODO: This needs setConsole() instead of setOutput() (currently used everywhere).        if ($console->input->isInteractive()) {            // TODO: Launch system browser to view `http://localhost:$port/devtools/wdp_client.html`, which will wait for a working WS connection and start opening tabs.            $console->confirm('Please press <info>[enter]</> to continue...');        } else {            $console->writeln("Waiting for {$this->timeout} seconds (timeout on non-interactive console)...", OutputInterface::VERBOSITY_VERY_VERBOSE);            \sleep($this->timeout);        }        $tabs = [];        foreach ($this->tabs as $tab) {        }        $console->writeln(' ==> ' . __METHOD__ . ': Done.', OutputInterface::VERBOSITY_DEBUG);        return $tabs ?? [];    }    /**     * @throws FileTemplateDumpException     */    protected function dumpWdpClient(): void    {        $console = $this->getConsole();        $fileTemplate = (new WebsocketWdpClient($this->file, $this->tabs))            ->setOutput($this->getOutput())            ->setFileDate($this->getFileDate());        $filename     = $fileTemplate->getFilename();        $content      = (string)$fileTemplate;        try {            $this->filesystem->dumpFile($filename, $content);        } catch (IOException $exception) {            $console->writeln('Error writing file: ' . $exception->getMessage(), OutputInterface::VERBOSITY_VERY_VERBOSE);            throw FileTemplateDumpException::fromIOException($exception);        }    }    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////    public function setOutput(OutputInterface $output): static    {        $this->jsonFileLoader->setOutput($output);        return $this->parent__setOutput($output);    }    public function setInput(InputInterface $input): static    {        $this->jsonFileLoader->setInput($input);        return $this->parent__setInput($input);    }    public function setConsole(Console $console): static    {        $this->jsonFileLoader->setConsole($console);        return $this->parent__setConsole($console);    }    public function setDebug(bool $debug): static    {        $this->jsonFileLoader->setDebug($debug);        return $this->parent__setDebug($debug);    }    public function setFileDate(?\DateTimeInterface $date): static    {        $this->jsonFileLoader->setFileDate($date);        return $this->parent__setFileDate($date);    }}